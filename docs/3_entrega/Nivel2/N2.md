# C4 Nível 2 - Diagrama de Containers

## 1. Visão Geral da Arquitetura
O diagrama de Nível 2 desce ao nível dos contentores (unidades de execução e persistência), revelando uma arquitetura de **Microsserviços Orientada a Eventos**. O sistema foi desenhado para maximizar o desacoplamento, a escalabilidade e a resiliência, utilizando padrões avançados como **CQRS** (Command Query Responsibility Segregation) e **Saga Coreografada**.

A comunicação é híbrida: **Síncrona (HTTP)** para a interação com o cliente externo e **Assíncrona (AMQP)** para a orquestração de processos de negócio internos.

## 2. Componentes de Entrada e Infraestrutura
*   **API Gateway (Spring Cloud Gateway):**
    *   Atua como o ponto de entrada único para todos os pedidos externos.
    *   **Responsabilidades:** Encaminhamento de rotas, Terminação SSL/TLS, aplicação de *Rate Limiting* e, crucialmente para a Observabilidade, a **geração de Trace-IDs** para rastreio distribuído. Gere também a segurança **mTLS** na comunicação com os microsserviços internos.
*   **Identity Service (Keycloak):**
    *   Serviço dedicado à gestão de identidades e acessos (IAM). Emite e valida tokens **JWT** (JSON Web Tokens), retirando a complexidade de autenticação dos serviços de negócio.
*   **Message Broker (RabbitMQ):**
    *   A espinha dorsal da arquitetura distribuída. Permite que os serviços comuniquem sem acoplamento temporal ou espacial, suportando o padrão **Saga Coreografada**.

## 3. Microsserviços de Negócio
Cada serviço é autónomo, possui o seu próprio ciclo de vida e base de dados (*Database-per-Service*).

*   **Scheduling Service (O Coração do Sistema):**
    *   Gere o ciclo de vida das consultas. É o serviço mais complexo, implementando **CQRS** e **Event Sourcing**.
    *   Não comunica diretamente com *Patient* ou *Physician* para validar regras; em vez disso, publica eventos (`AppointmentCreated`) no Broker e reage a respostas assíncronas.
*   **Patient Service & Physician Service:**
    *   Serviços de domínio que gerem as entidades Paciente e Médico. Atuam como **participantes na Saga**, escutando eventos de agendamento e emitindo validações (`PatientValidated`, `PhysicianConfirmed`).
*   **Clinical Records Service:**
    *   Gere os prontuários médicos. Reage a eventos de consultas para permitir a inserção de notas clínicas.

## 4. Persistência de Dados (CQRS e Event Sourcing)
A arquitetura adota persistência poliglota e segregada para otimizar escrita e leitura:

*   **Event Store (PostgreSQL):**
    *   Utilizado pelo *Scheduling Service* para a vertente de **Escrita (Command)**. Em vez de guardar o estado atual, guarda um log imutável de eventos (`Append-Only`), garantindo auditoria completa e consistência transacional na Saga.
*   **Read DB (H2/Projeções):**
    *   Utilizado pelo *Scheduling Service* para a vertente de **Leitura (Query)**. Armazena dados desnormalizados e otimizados para consultas rápidas e relatórios, atualizados assincronamente através do processamento de eventos.
*   **Bases de Dados de Domínio (H2):**
    *   Cada um dos restantes serviços (*Patient, Physician, Auth*) mantém a sua própria base de dados isolada, garantindo que nenhum serviço acede diretamente aos dados de outro.

## 5. Padrões de Comunicação
*   **HTTP/REST (Linhas Pretas):** Usado estritamente para a comunicação "Norte-Sul" (Cliente -> Gateway -> Serviço) e para validação de tokens.
*   **AMQP/Messaging (Linhas Vermelhas):** Usado para a comunicação "Este-Oeste" (Serviço -> Serviço).
    *   *Exemplo:* O `Scheduling Service` publica no RabbitMQ. O `Patient Service` e o `Physician Service` subscrevem a fila, processam a lógica e respondem via eventos. Isto elimina chamadas HTTP bloqueantes em transações distribuídas, aumentando a resiliência a falhas parciais.